import sys
import os
import logging
import argparse
import torch
import matplotlib.pyplot as plt

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    filemode="w",
    filename="./logs/test.log",
)

sys.path.append("src/")

from generator import Generator
from utils import device_init, load_pickle, train_parameters as params
from config import to_save, BEST_MODELS, TEST_IMAGE_PATH


class Test:
    """
    Test class for generating and visualizing predictions from a trained Generator model.

    This class is responsible for loading a trained model, generating predictions for a set number of samples, and
    visualizing these predictions.

    **Methods**

    +----------------------+------------------------------------------------------------------+
    | Method               | Description                                                      |
    +======================+==================================================================+
    | __setup__            | Sets up the device and loads training parameters.                |
    +----------------------+------------------------------------------------------------------+
    | select_optimal_model | Loads the state dictionary of the best-performing model.         |
    +----------------------+------------------------------------------------------------------+
    | visualize_predictions| Visualizes a set of images generated by the model.               |
    +----------------------+------------------------------------------------------------------+
    | generate_noise_samples | Generates noise samples for the generator input.               |
    +----------------------+------------------------------------------------------------------+
    | test                 | Main method to load the model, generate predictions, and         |
    |                      | visualize them.                                                  |
    +----------------------+------------------------------------------------------------------+

    **Parameters**

    +----------------+--------+---------------------------------------------------------------+
    | Parameter      | Type   | Description                                                   |
    +================+========+===============================================================+
    | best_model_path| str    | Path to the best model's state dictionary. If None, the       |
    |                |        | method will attempt to find the best model automatically.     |
    +----------------+--------+---------------------------------------------------------------+
    | num_samples    | int    | Number of sample images to generate.                          |
    +----------------+--------+---------------------------------------------------------------+
    | label          | int    | Specific label for generating images.                         |
    +----------------+--------+---------------------------------------------------------------+
    | latent_space   | int    | Dimension of the latent space for the generator.              |
    +----------------+--------+---------------------------------------------------------------+
    | device         | str    | Computational device ('cuda', 'cpu', 'mps').                  |
    +----------------+--------+---------------------------------------------------------------+
    """

    def __init__(
        self,
        best_model_path=None,
        num_samples=20,
        label=1,
        latent_space=50,
        device="mps",
    ):
        self.best_model_path = best_model_path
        self.num_samples = num_samples
        self.specific_labels = label
        self.latent_space = latent_space
        self.device = device

        self.__setup__()

    def __setup__(self):
        """
        Sets up the device for computation and loads necessary training parameters.
        """
        self.device = device_init(device=self.device)
        self.params = params()

    def select_optimal_model(self):
        """
        Selects and loads the best-performing model based on saved checkpoints.

        **Returns**

        A state dictionary of the selected model.
        """
        if self.best_model_path is None:
            if os.path.exists(BEST_MODELS):
                return torch.load(
                    os.path.join(
                        BEST_MODELS,
                        "netG_{}.pth".format(
                            max(
                                torch.load(os.path.join(BEST_MODELS, model))["epochs"]
                                for model in os.listdir(BEST_MODELS)
                            )
                        ),
                    )
                )["G_load_state_dict"]

            else:
                raise Exception("No best model path found".title())
        else:
            return torch.load(self.best_model_path)["G_load_state_dict"]

    def visualize_predictions(self, images=None):
        """
        Visualizes generated images.

        **Parameters**

        +---------+--------------+-------------------------------------------------------------+
        | Parameter | Type        | Description                                                 |
        +==========+==============+=============================================================+
        | images   | torch.Tensor | Tensor containing generated images to visualize.            |
        +---------+--------------+-------------------------------------------------------------+
        """
        if images is not None:
            dataset = load_pickle(os.path.join(to_save, "dataset.pkl"))
            dataset = {index: label.split("_")[0] for label, index in dataset.items()}

            plt.figure(figsize=(10, 5))
            for index, image in enumerate(images):
                image = image.detach().cpu().permute(1, 2, 0)
                image = (image - image.min()) / (image.max() - image.min())

                plt.subplot(2, self.num_samples // 2, index + 1)
                plt.imshow(image, cmap="gray")
                plt.title("{}".format(dataset[self.specific_labels]), rotation=45)
                plt.axis("off")

            plt.tight_layout()

            if os.path.exists(TEST_IMAGE_PATH):
                plt.savefig(os.path.join(TEST_IMAGE_PATH, "predictions.png"))

                plt.show()
            else:
                raise Exception("No test image path found".title())

    def generate_nose_samples(self):
        """
        Generates noise samples and corresponding labels for image generation.

        **Returns**

        A tuple containing noise samples and labels tensors.
        """
        return torch.randn(self.num_samples, self.latent_space, 1, 1).to(
            self.device
        ), torch.full((self.num_samples,), self.specific_labels, dtype=torch.long).to(
            self.device
        )

    def test(self):
        """
        Main method for model testing. Loads the model, generates images, and visualizes them.
        """
        netG = Generator(
            latent_space=self.latent_space,
            num_labels=4,
            image_size=64,
            in_channels=1,
        ).to(self.device)

        netG.load_state_dict(self.select_optimal_model())

        noise_samples, labels = self.generate_nose_samples()

        images = netG(noise_samples, labels)

        self.visualize_predictions(images=images)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test the model".title())
    parser.add_argument(
        "--model_path", type=str, default=None, help="Path to the model".capitalize()
    )
    parser.add_argument(
        "--num_samples",
        type=int,
        default=4,
        help="Number of samples to generate".capitalize(),
    )
    parser.add_argument(
        "--label", type=int, default=0, help="Label for the samples".capitalize()
    )
    parser.add_argument(
        "--latent_space",
        type=int,
        default=100,
        help="Latent space dimension".capitalize(),
    )
    parser.add_argument(
        "--device",
        type=str,
        default="cuda" if torch.cuda.is_available() else "cpu",
        help="Device to run the model on".capitalize(),
    )

    args = parser.parse_args()

    if args.model_path is None:
        logging.info("No model path provided. Using the default model.")

        test = Test(
            num_samples=args.num_samples,
            label=args.label,
            latent_space=args.latent_space,
            device=args.device,
        )

        test.test()

        logging.info("Test complete.")

    elif args.model_path is not None:

        logging.info("Loading model from path: {}".format(args.model_path))

        test = Test(
            best_model_path=args.model_path,
            num_samples=args.num_samples,
            label=args.label,
            latent_space=args.latent_space,
            device=args.device,
        )

        test.test()

        logging.info("Test complete.")
